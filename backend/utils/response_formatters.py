import logging
from typing import Any, Dict, List, Optional

from utils.file_saver import get_output_path, save_json, save_text

logger = logging.getLogger(__name__)


def format_upload_response(extraction_result: Dict[str, Any]) -> Dict[str, Any]:
    if not extraction_result:
        raise ValueError("Extraction result cannot be empty.")

    file_name = extraction_result.get("file_name", "unknown")
    result_text = extraction_result.get("result_text")
    whisper_hash = extraction_result.get("whisper_hash")

    logger.info(f"Formatting response for '{file_name}': text_len={len(result_text) if result_text else 0}, hash={whisper_hash}")

    if not result_text:
        logger.error(f"No text returned for '{file_name}'. Full result: {extraction_result}")
        raise ValueError(f"No text returned for '{file_name}'.")
    if not whisper_hash:
        raise ValueError(f"Missing whisper hash for '{file_name}'.")

    # Save extracted text as .txt file (not JSON)
    # This preserves the exact layout_preserving text from LLMWhisperer
    try:
        text_path = get_output_path(file_name, suffix="_text", prefix="02", extension="txt")
        save_text(text_path, result_text)
        logger.info("Saved extracted text to %s", text_path)
    except Exception as e:
        logger.warning(f"Failed to save extracted text: {e}")
        # Continue processing even if saving fails

    # Save bounding boxes to output_files/ with improved format
    # Format: Includes both line_metadata (line-level) and words (word-level) boxes
    bounding_boxes = _safe_get(extraction_result, "bounding_boxes")
    if bounding_boxes:
        try:
            bboxes_path = get_output_path(file_name, suffix="_bboxes", prefix="03")
            formatted_bboxes = _format_bounding_boxes_for_save(
                bounding_boxes, result_text, whisper_hash
            )
            save_json(bboxes_path, formatted_bboxes)
            logger.info("Saved bounding boxes to %s", bboxes_path)
        except Exception as e:
            logger.warning(f"Failed to save bounding boxes: {e}")
            # Continue processing even if saving fails

    return {
        "fileName": file_name,
        "text": result_text,
        "whisperHash": whisper_hash,
        "boundingBoxes": bounding_boxes,
        "pages": _safe_get(extraction_result, "pages"),
    }


def _safe_get(source: Dict[str, Any], key: str) -> Optional[Any]:
    value = source.get(key)
    return value if value not in ({}, []) else None


def _format_bounding_boxes_for_save(
    bounding_boxes: Any, result_text: str, whisper_hash: str
) -> Dict[str, Any]:
    """
    Format bounding boxes for saving.
    
    Backend generates word-level boxes from line-level boxes returned by LLMWhisperer.
    Save both line_metadata (for reference) and words (for highlighting).
    
    Args:
        bounding_boxes: Bounding box data (contains both line_metadata and words)
        result_text: The extracted text (split by lines to match line numbers)
        whisper_hash: Whisper hash for reference
        
    Returns:
        Formatted dictionary with line entries and word entries
    """
    lines = result_text.split("\n")
    formatted_lines: List[Dict[str, Any]] = []
    
    # Extract word-level boxes (generated by backend)
    words = []
    if isinstance(bounding_boxes, dict):
        words = bounding_boxes.get("words") or []
    
    # Handle different bounding box structures for line metadata
    line_metadata = None
    if isinstance(bounding_boxes, dict):
        line_metadata = bounding_boxes.get("line_metadata") or bounding_boxes.get("lines")
    elif isinstance(bounding_boxes, list):
        line_metadata = bounding_boxes
    
    # Process line metadata (for reference)
    if line_metadata and isinstance(line_metadata, list):
        for idx, line_data in enumerate(line_metadata):
            line_number = None
            raw_box = None
            text = lines[idx] if idx < len(lines) else ""
            
            if isinstance(line_data, dict):
                line_number = line_data.get("line_no") or line_data.get("line_number") or line_data.get("line") or (idx + 1)
                # Extract bounding box - format may vary
                bbox = line_data.get("bbox") or line_data.get("bounding_box") or line_data.get("box") or line_data.get("raw_box")
                if bbox:
                    if isinstance(bbox, list) and len(bbox) >= 4:
                        # Assume format: [page, base_y, height, page_height]
                        raw_box = bbox[:4]
                    elif isinstance(bbox, dict):
                        # Convert dict to list format
                        page = bbox.get("page", 1)
                        base_y = bbox.get("y") or bbox.get("base_y") or bbox.get("top", 0)
                        height = bbox.get("height", 0)
                        page_height = bbox.get("page_height") or bbox.get("pageHeight", 0)
                        raw_box = [page, base_y, height, page_height]
            else:
                line_number = idx + 1
                raw_box = None
            
            formatted_lines.append({
                "line_number": int(line_number) if line_number is not None else (idx + 1),
                "text": text,
                "raw_box": raw_box if raw_box else None
            })
    
    # Return both line_metadata and words
    result = {
        "whisperHash": whisper_hash,
        "line_metadata": formatted_lines,
    }
    
    # Add word-level boxes if available
    if words:
        result["words"] = words
    
    return result
